#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#define V 8

using namespace std;

// Структура для хранения информации о рёбре графа
struct Edge 
{
    int u;
    int v;
    int weight; // u и v - вершины, соединённые рёбром, weight - вес ребра
};

// Функция для нахождения родителя вершины в дереве (для алгоритма Краскала)
int findParent(int vertex, vector<int>& parent) 
{
    // Если вершина является своим собственным родителем, возвращаем её
    if (parent[vertex] == vertex) return vertex;
    // Иначе рекурсивно находим корневого родителя и обновляем для оптимизации (сжатие путей)
    return parent[vertex] = findParent(parent[vertex], parent);
}

// Функция для объединения двух поддеревьев в одно дерево (для алгоритма Краскала)
void unionVertices(int u, int v, vector<int>& parent, vector<int>& rank) 
{
    u = findParent(u, parent); // Находим корневого родителя вершины u
    v = findParent(v, parent); // Находим корневого родителя вершины v
    if (rank[u] < rank[v]) {
        parent[u] = v; // Присоединяем дерево с корнем u к дереву с корнем v
    }
    else if (rank[u] > rank[v]) {
        parent[v] = u; // Присоединяем дерево с корнем v к дереву с корнем u
    }
    else {
        parent[v] = u; // Если ранги равны, присоединяем дерево с корнем v к дереву с корнем u
        rank[u]++; // Увеличиваем ранг дерева с корнем u
    }
}

// Функция для построения минимального остовного дерева (MST) по алгоритму Краскала
void kruskalMST(vector<Edge>& edges) 
{
    // Сортируем рёбра по весу в порядке возрастания
    sort(edges.begin(), edges.end(), [](Edge a, Edge b) 
        {
            return a.weight < b.weight;
        });

    vector<int> parent(V); // Вектор для хранения родителя каждой вершины
    vector<int> rank(V, 0); // Вектор для хранения рангов деревьев (для оптимизации слияний)
    for (int i = 0; i < V; ++i) {
        parent[i] = i; // Изначально каждая вершина является своим собственным родителем
    }

    vector<Edge> mst; // Вектор для хранения рёбер минимального остовного дерева
    int mstWeight = 0; // Переменная для хранения общего веса MST

    // Проходим по всем рёбрам и добавляем их в MST, если они не создают цикл
    for (Edge& edge : edges) {
        if (findParent(edge.u, parent) != findParent(edge.v, parent)) {
            mst.push_back(edge); // Добавляем ребро в MST
            mstWeight += edge.weight; // Добавляем вес ребра к общему весу MST
            unionVertices(edge.u, edge.v, parent, rank); // Объединяем два поддерева
        }
    }

    // Выводим результат (MST) и его общий вес
    cout << "Минимальное остовное дерево по Краскалу:" << endl;
    for (auto& edge : mst) 
    {
        cout << "Вершина " << edge.u + 1 << " - Вершина " << edge.v + 1 << " : Вес " << edge.weight << endl;
    }
    cout << "Общий вес: " << mstWeight << endl;
}

// Функция для построения минимального остовного дерева по алгоритму Прима
void primMST(int graph[V][V]) {
    vector<int> key(V, INT_MAX); // Вектор для хранения минимальных ключей (весов рёбер)
    vector<bool> inMST(V, false); // Вектор для отметки, включена ли вершина в MST
    vector<int> parent(V, -1); // Вектор для хранения родителей вершин в MST

    key[0] = 0; // Начинаем с первой вершины, ключ которой равен 0
    parent[0] = -1; // У первой вершины нет родителя

    // Строим MST для всех вершин графа
    for (int i = 0; i < V - 1; ++i) 
    {
        int minKey = INT_MAX, u; // Инициализируем минимальный ключ как максимальное значение
        for (int v = 0; v < V; ++v) 
        {
            if (!inMST[v] && key[v] < minKey) 
            {
                minKey = key[v]; // Находим вершину с минимальным ключом, которая ещё не включена в MST
                u = v;
            }
        }

        inMST[u] = true; // Включаем найденную вершину в MST

        // Обновляем ключи для смежных вершин
        for (int v = 0; v < V; ++v) 
        {
            if (graph[u][v] && !inMST[v] && graph[u][v] < key[v]) 
            {
                key[v] = graph[u][v]; // Обновляем ключ, если найдено более лёгкое ребро
                parent[v] = u; // Указываем родителя для вершины
            }
        }
    }

    // Выводим результат (MST) и его общий вес
    cout << "Минимальное остовное дерево по Приму:" << endl;
    int mstWeight = 0; // Переменная для хранения общего веса MST
    for (int i = 1; i < V; ++i) {
        cout << "Вершина " << parent[i] + 1 << " - Вершина " << i + 1 << " : Вес " << graph[i][parent[i]] << endl;
        mstWeight += graph[i][parent[i]]; // Добавляем вес ребра к общему весу MST
    }
    cout << "Общий вес: " << mstWeight << endl;
    
    
}

int main()
{
    setlocale(LC_ALL, "Rus");

    // Определяем граф как матрицу смежности
    int graph[V][V] = 
    {
        {0, 2, 0, 8, 2, 0, 0, 0},
        {2, 0, 3, 10, 5, 0, 0, 0},
        {0, 3, 0, 0, 12, 0, 0, 7},
        {8, 10, 0, 0, 14, 3, 1, 0},
        {2, 5, 12, 14, 0, 11, 4, 8},
        {0, 0, 0, 3, 11, 0, 6, 0},
        {0, 0, 0, 1, 4, 6, 0, 9},
        {0, 0, 7, 0, 8, 0, 9, 0}
    };

    // Определяем граф как список рёбер
    vector<Edge> edges = 
    {
        {0, 1, 2}, {0, 4, 2}, {0, 3, 8},
        {1, 2, 3}, {1, 3, 10}, {1, 4, 5},
        {2, 4, 12}, {2, 7, 7},
        {3, 4, 14}, {3, 5, 3}, {3, 6, 1},
        {4, 5, 11}, {4, 6, 4},
        {5, 6, 6},
        {6, 7, 9}
    };

    cout << "Алгоритм Прима:" << endl;
    primMST(graph);
    cout << "Сложность алгоритма Прима: O(V^2)" << endl;    // V - кол-во вершин

    cout << "\nАлгоритм Краскала:" << endl;
    kruskalMST(edges);
    cout << "Сложность алгоритма Крускала: O(ElogV)" << endl; // E - Кол-во ребер, V - кол-во вершин
    cout << "Цикломатическое число: " << 16 - 8 + 1 << endl;

    return 0;
}
